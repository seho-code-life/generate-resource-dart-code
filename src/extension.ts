import { posix } from 'path';
import * as vscode from 'vscode';

type AssetsFolder = 'images' | 'svgs';

// 资源缓存对象
const assets: Record<AssetsFolder, Record<string, string>> = { images: {}, svgs: {} };
// dart code缓存对象
const dartCodeCache: Record<AssetsFolder, string> = { images: '', svgs: '' };

// debounce
const debounce = (fn: any, delay: number) => {
	let timer: NodeJS.Timeout;
	return (...args: any[]) => {
		clearTimeout(timer);
		timer = setTimeout(() => {
			fn(...args);
		}, delay);
	};
};

// 处理file格式, 返回符合要求的文件名和文件格式
const handleFile = (file: vscode.Uri): { fileNameCamel?: string; fileFormatCamel?: string } => {
	// 获取当前文件所属的是assets文件夹下哪个文件夹
	// const assetsFolder = file.path.indexOf() as AssetsFolder;
	// 从path中获取文件名, 排除格式
	const fileName = file.path.split('/').pop()?.split('.').shift();
	// 从文件名中获取格式
	const fileFormatCamel = file.path
		.split('/')
		.pop()
		?.split('.')
		.pop()
		?.replace(/^\S/, (s) => s.toUpperCase());
	// 判断name是否是下划线命名或者-命名, 如果是_或者-命名, 就转换成驼峰命名, 如果存在空格, 就去掉空格, 如果首字母是大写就转换成小写
	const fileNameCamel = fileName
		?.replace(/\s/g, '')
		.replace(/^\S/, (s) => s.toLowerCase())
		.replace(/[_-]\S/g, (s) => {
			// 判断s是否是数字, 如果是数字(包括0)不用转换
			if (Number(s[1]) || s[1] === '0') {
				return s;
			}
			return s.slice(1).toUpperCase();
		});
	return {
		fileNameCamel,
		fileFormatCamel
	};
};

// 处理缓存对象的数据结构, 提供file对象和缓存对象引用为参数, 返回缓存对象引用
type CacheHandler = (file: vscode.Uri, cache: Record<string, string>) => Record<string, string>;
const cacheHandler: CacheHandler = (file, cache) => {
	const { fileNameCamel, fileFormatCamel } = handleFile(file);
	// 把key value对添加到对象中
	cache[`${fileNameCamel}${fileFormatCamel}`] = file.path.substring(file.path.indexOf('assets'));
	return cache;
};

// 将缓存对象转换为dart code
const cacheToDartCode = async (
	cache: Record<string, string>,
	className: AssetsFolder,
	options?: {
		// 是否需要覆盖assets.dart文件
		cover?: boolean;
		// 是否提示成功
		tip?: boolean;
	}
): Promise<void> => {
	// 将cache按照key排序
	const sortedCache = Object.keys(cache)
		.sort()
		.reduce((acc, key) => {
			acc[key] = cache[key];
			return acc;
		}, {} as Record<string, string>);
	const val = Object.entries(sortedCache)
		.map(([key, value]) => `  static const ${key} = '${value}';`)
		.join('\n');
	const dartCode = `class Assets${className?.replace(/^\S/, (s) => s.toUpperCase())} {\n${val}\n}`;
	// 将code缓存到dartCodeCache中
	dartCodeCache[className] = dartCode;
	// 如果需要覆盖原有的assets.dart文件, 就写入文件
	if (options?.cover) {
		// 循环缓存的dart code
		let code = '// code generated by [generate-resource-dart-code] vscode-extension.\n';
		Object.entries(dartCodeCache).forEach(([key, value]) => {
			code += value + '\n\n';
		});
		const folderUri = vscode.workspace.workspaceFolders![0].uri;
		const fileUri = folderUri.with({ path: posix.join(folderUri.path, 'lib', 'assets.dart') });
		await vscode.workspace.fs.writeFile(fileUri, Buffer.from(code));
		// 如果不提示成功, 就不提示
		if (options?.tip) {
			vscode.window.showInformationMessage(
				`[generate-resource-dart-code] ${className}内容已成功生成🎉`
			);
		}
	}
};

// 遍历对应资源文件夹下的所有文件, 并且将文件名和文件路径添加到缓存对象中
const traverseAssetsFolder = async (
	key: AssetsFolder,
	options?: { clear?: boolean }
): Promise<void> => {
	// 如果clear为true, 就清空缓存对象
	if (options?.clear) {
		assets[key] = {};
	}
	// 遍历对应资源文件夹下的所有文件
	const files = await vscode.workspace.findFiles(`assets/${key}/**`);
	// 初始化缓存对象
	files.forEach((file) => {
		cacheHandler(file, assets[key as AssetsFolder]);
	});
};

// 迭代资源文件夹, 初始化缓存对象的封装方法
const init = async (clear: boolean, cb?: (key: AssetsFolder) => void): Promise<void> => {
	for (let key in assets) {
		await traverseAssetsFolder(key as AssetsFolder, { clear });
		cacheToDartCode(assets[key as AssetsFolder], key as AssetsFolder, { cover: true, tip: true });
		cb && cb(key as AssetsFolder);
	}
};

export async function activate(context: vscode.ExtensionContext) {
	// 获取当前项目的根目录第一级文件
	const isFlutter = await vscode.workspace.findFiles('pubspec.yaml');
	if (isFlutter.length === 0) {
		// 如果不存在pubspec.yaml文件，直接返回
		return;
	}
	// 注册命令
	const disposable = vscode.commands.registerCommand(
		'extension.generateResourceDartCode',
		async () => {
			init(true);
		}
	);
	context.subscriptions.push(disposable);

	init(false, async (key) => {
		let watcher = vscode.workspace.createFileSystemWatcher(`**/assets/${key}/**`);
		watcher.onDidCreate(async (uri: vscode.Uri) => {
			// 创建/修改文件都会触发这个事件, 但是回调并没有提供old, new的uri (自己不能根据缓存对象diff), 所以只能重新遍历文件夹生成缓存对象
			await traverseAssetsFolder(key as AssetsFolder, { clear: true });
			debounce(
				cacheToDartCode(assets[key as AssetsFolder], key as AssetsFolder, { cover: true }),
				500
			);
		});
		watcher.onDidDelete(async (uri: vscode.Uri) => {
			const { fileNameCamel, fileFormatCamel } = handleFile(uri);
			if (assets[key as AssetsFolder][`${fileNameCamel}${fileFormatCamel}`]) {
				delete assets[key as AssetsFolder][`${fileNameCamel}${fileFormatCamel}`];
			}
			debounce(
				cacheToDartCode(assets[key as AssetsFolder], key as AssetsFolder, { cover: true }),
				500
			);
		});
	});
}
